RecetEasy: qué hace la app y cómo está implementada

RecetEasy es una app móvil de recetas hecha en Kotlin usando Jetpack Compose y arquitectura MVVM. Permite que un usuario se registre o inicie sesión, mantenga su sesión activa, cree nuevas recetas indicando título, descripción, una lista de ingredientes (con nombre, cantidad y unidad), pasos de preparación y una imagen opcional desde galería o cámara; si no se elige imagen, se usan imágenes por defecto tanto para el usuario como para las recetas. La persistencia interna se implementa con Room: existe un RecetaDao con las operaciones básicas (obtener todas las recetas, buscar por id, insertar, eliminar), un RecetaRepository que encapsula el acceso a la base de datos y un RecetarioViewModel que se suscribe a un Flow de recetas en el init, actualizando un StateFlow de estado de UI con la lista de recetas, el estado de carga, errores y el nombre del usuario. Cuando el usuario crea una receta, la pantalla de creación valida los campos obligatorios (título, al menos un ingrediente y pasos), construye un objeto Receta con los ingredientes temporales que se fueron agregando, la imagen (o un valor por defecto) y el creador, y luego el ViewModel la guarda en la base de datos mediante el repositorio; el flujo de Room notifica el cambio y la lista de la pantalla de inicio se actualiza automáticamente. Para la persistencia externa y el consumo de API REST se usa Retrofit apuntando a Xano: se definió un RetrofitInstance con la base URL del grupo de ingredientes, una interfaz ApiService con un endpoint GET ingrediente y un modelo IngredienteRemote alineado al JSON que entrega Xano (id, name, created_at). Un IngredientesRemoteViewModel llama a obtenerIngredientes() dentro de una corrutina y expone un estado simple con cargando, ingredientes y error, que es observado por la pantalla PantallaListaIngredientesRemotos, donde se muestra un loader mientras se carga, un mensaje en caso de error y una lista con los ingredientes remotos cuando la petición es exitosa. El manejo de sesión se hace con SharedPreferences a través de un UsuarioViewModel y un gestor de sesión, guardando el nombre del usuario y la URI de la foto para mantener la sesión entre aperturas; además, hay un botón de cerrar sesión que limpia los datos de sesión, resetea el estado en los ViewModels y navega de vuelta a la pantalla de bienvenida. En resumen, la app separa la lógica de datos (Room y Retrofit), la lógica de negocio (ViewModels y repositorio) y la UI (pantallas Compose), cumpliendo con persistencia interna, consumo de API externa y una estructura MVVM clara y defendible en la presentación.


Tests unitarios en RecetEasy: qué se hizo y cómo usarlo

En RecetEasy se implementaron tests unitarios para verificar partes clave de la lógica sin depender del emulador ni del celular. Se probaron principalmente dos cosas: (1) el modelo Ingrediente, asegurando que al crear y copiar un ingrediente se mantengan correctamente sus datos (id, nombre, unidad, cantidad); y (2) el RecetarioViewModel, comprobando que al llamar a agregarIngrediente("Tomate", 2.0, "unidades") se agregue exactamente un ingrediente a la lista temporal, el nombre se normalice a minúsculas y se conserven unidad y cantidad tal como se enviaron. Para esto se utilizaron tres dependencias en el módulo app: JUnit 4 (framework de pruebas), kotlinx-coroutines-test (para probar corrutinas con runTest) y MockK (para simular RecetaRepository sin base de datos real). Los tests están en src/test/java/cl/duoc/receteasy, organizados en IngredienteTest y RecetarioViewModelTest. Para ejecutarlos, se puede usar Android Studio (abrir el archivo de test y presionar el botón Run junto a la clase o método @Test) o la terminal con Gradle (por ejemplo, ./gradlew testDebugUnitTest o un comando más específico para una clase de test). Cuando estos tests pasan correctamente, se demuestra que parte de la lógica central de la app está verificada de forma automática.
